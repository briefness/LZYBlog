import{_ as i,o as a,c as n,ag as t}from"./chunks/framework.CbQjVMS6.js";const E=JSON.parse('{"title":"鸿蒙开发高级（十七）：性能调优实战 (Performance Deep Dive)","description":"","frontmatter":{},"headers":[],"relativePath":"posts/harmonyos/Articles/Performance.md","filePath":"posts/harmonyos/Articles/Performance.md"}'),l={name:"posts/harmonyos/Articles/Performance.md"};function e(h,s,p,k,r,o){return a(),n("div",null,[...s[0]||(s[0]=[t(`<h1 id="鸿蒙开发高级-十七-性能调优实战-performance-deep-dive" tabindex="-1">鸿蒙开发高级（十七）：性能调优实战 (Performance Deep Dive) <a class="header-anchor" href="#鸿蒙开发高级-十七-性能调优实战-performance-deep-dive" aria-label="Permalink to &quot;鸿蒙开发高级（十七）：性能调优实战 (Performance Deep Dive)&quot;">​</a></h1><blockquote><p>🔗 <strong>项目地址</strong>：<a href="https://github.com/briefness/HarmonyDemo" target="_blank" rel="noreferrer">https://github.com/briefness/HarmonyDemo</a></p></blockquote><blockquote><p><strong>摘要</strong>：性能直接决定 App 的用户体验。本文将从<strong>底层渲染原理</strong>出发，剖析<strong>UI 渲染瓶颈</strong>、<strong>ArkTS 内存管理</strong>，并结合 <strong>DevEco Profiler</strong> 工具，提供性能优化解决方案。</p></blockquote><h2 id="一、核心理论-流畅度的本质" tabindex="-1">一、核心理论：流畅度的本质 <a class="header-anchor" href="#一、核心理论-流畅度的本质" aria-label="Permalink to &quot;一、核心理论：流畅度的本质&quot;">​</a></h2><p>要优化性能，首先要理解“卡顿”从何而来。</p><h3 id="_1-1-16-6ms-刷新率与-vsync" tabindex="-1">1.1 16.6ms 刷新率与 VSync <a class="header-anchor" href="#_1-1-16-6ms-刷新率与-vsync" aria-label="Permalink to &quot;1.1 16.6ms 刷新率与 VSync&quot;">​</a></h3><p>大多数手机屏幕刷新率为 60Hz，意味着每帧的时间窗口仅有 <strong>16.6ms</strong>（1000ms / 60）。</p><ul><li><strong>VSync (垂直同步信号)</strong>：每 16.6ms 发送一次信号，通知 CPU/GPU 开始准备下一帧画面。</li><li><strong>掉帧 (Jank)</strong>：如果代码逻辑（JS 执行 + 布局计算 + 渲染指令生成）耗时超过 16.6ms，错过了当次 VSync 信号，屏幕就会保持显示上一帧的画面。连续丢帧会导致明显的“卡顿”。</li></ul><h3 id="_1-2-渲染管线-render-pipeline" tabindex="-1">1.2 渲染管线 (Render Pipeline) <a class="header-anchor" href="#_1-2-渲染管线-render-pipeline" aria-label="Permalink to &quot;1.2 渲染管线 (Render Pipeline)&quot;">​</a></h3><p>HarmonyOS 的渲染流程大致如下：</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    VSync[&quot;VSync 信号&quot;] --&gt; JS[&quot;1. JS 执行 (@State更新/业务逻辑)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    JS --&gt; Diff[&quot;2. UI 差异计算 (对比组件树)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Diff --&gt; Measure[&quot;3. 测量 (计算大小)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Measure --&gt; Layout[&quot;4. 布局 (计算位置)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Layout --&gt; Render[&quot;5. 渲染 (生成绘制指令)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Render --&gt; RS{&quot;渲染服务&quot;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RS --&gt; GPU[GPU 合成与光栅化]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style JS fill:#ffcccc,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Diff fill:#ffcccc,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Measure fill:#ffffcc,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Layout fill:#ffffcc,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Render fill:#ccffcc,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style RS fill:#ccccff,stroke:#333</span></span></code></pre></div><p><strong>优化核心目标</strong>：减少 Diff 范围、降低 Layout 复杂度、缩短 JS 执行时间。</p><hr><h2 id="二、列表渲染优化-重中之重" tabindex="-1">二、列表渲染优化：重中之重 <a class="header-anchor" href="#二、列表渲染优化-重中之重" aria-label="Permalink to &quot;二、列表渲染优化：重中之重&quot;">​</a></h2><p>长列表（List/Grid）是性能问题的常见区域。</p><h3 id="_2-1-必须使用-lazyforeach" tabindex="-1">2.1 必须使用 LazyForEach <a class="header-anchor" href="#_2-1-必须使用-lazyforeach" aria-label="Permalink to &quot;2.1 必须使用 LazyForEach&quot;">​</a></h3><p>标准的 <code>ForEach</code> 会一次性渲染所有数据项，如果数据量大，启动瞬间会阻塞 UI 线程。<code>LazyForEach</code> 则按需渲染。</p><p><strong>代码对比</strong>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误示范：数据量大时易卡顿</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  ForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ListItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确示范</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  LazyForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dataSource, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ListItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.id) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 键值生成器至关重要！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-2-组件复用-reusable" tabindex="-1">2.2 组件复用 (@Reusable) <a class="header-anchor" href="#_2-2-组件复用-reusable" aria-label="Permalink to &quot;2.2 组件复用 (@Reusable)&quot;">​</a></h3><p>即使使用了 <code>LazyForEach</code>，当用户快速滑动时，频繁的创建（Create）和销毁（Destroy）组件依然会消耗 CPU 并触发 GC。 <strong>@Reusable</strong> 标记允许系统将滑出屏幕的组件缓存到“对象池”中，再次滑入时直接复用，只需更新数据。</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Screen[&quot;屏幕可视区&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Pool[&quot;复用池 (Recycle Pool)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Item1[&quot;Item 1 (滑出屏幕)&quot;] --&gt;|Recycle| Pool</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Pool --&gt;|Reuse| ItemX[&quot;Item X (即将滑入)&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ItemX -- &quot;aboutToReuse(params)&quot; --&gt; UpdateState[&quot;更新数据状态&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    UpdateState --&gt; Screen</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Pool fill:#bbf,stroke:#333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style Screen fill:#9f9,stroke:#333</span></span></code></pre></div><p><strong>实现步骤</strong>：</p><ol><li>自定义组件添加 <code>@Reusable</code> 装饰器。</li><li>实现 <code>aboutToReuse(params)</code> 接口，在此处更新状态。</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Reusable </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 标记为可复用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">struct ArticleCard {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @State </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @State </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">desc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2. 当组件被复用时回调，params 是新传入的参数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  aboutToReuse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params: { title: string, desc: string }) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.title </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> params.title;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.desc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> params.desc;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 技巧：这里不需要重新执行 build()，状态变量更新会自动触发局部的 UI 刷新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.title).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fontSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.desc).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fontColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Color.Gray)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-3-列表优化的策略" tabindex="-1">2.3 列表优化的策略 <a class="header-anchor" href="#_2-3-列表优化的策略" aria-label="Permalink to &quot;2.3 列表优化的策略&quot;">​</a></h3><p><strong>IDDataSource + LazyForEach + @Reusable + cachedCount</strong></p><ul><li><strong>cachedCount</strong>: 设置列表可视区域外预加载的节点数量，平滑滑动体验。<div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cachedCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 预加载屏幕外 2 个 Item，空间换时间</span></span></code></pre></div></li></ul><hr><h2 id="三、布局与渲染优化技巧" tabindex="-1">三、布局与渲染优化技巧 <a class="header-anchor" href="#三、布局与渲染优化技巧" aria-label="Permalink to &quot;三、布局与渲染优化技巧&quot;">​</a></h2><h3 id="_3-1-减少嵌套层级-layout-flattening" tabindex="-1">3.1 减少嵌套层级 (Layout Flattening) <a class="header-anchor" href="#_3-1-减少嵌套层级-layout-flattening" aria-label="Permalink to &quot;3.1 减少嵌套层级 (Layout Flattening)&quot;">​</a></h3><p>布局层级越深，<code>Measure</code> 和 <code>Layout</code> 耗时呈指数级增长。</p><ul><li><strong>优化前</strong>：嵌套了 3 层 Stack/Column 来实现重叠定位。</li><li><strong>优化后</strong>：使用 <code>RelativeContainer</code> 或 <code>GridRow</code>/<code>GridCol</code> 进行扁平化布局。</li></ul><h3 id="_3-2-显隐控制-if-vs-visibility" tabindex="-1">3.2 显隐控制：if vs visibility <a class="header-anchor" href="#_3-2-显隐控制-if-vs-visibility" aria-label="Permalink to &quot;3.2 显隐控制：if vs visibility&quot;">​</a></h3><ul><li><strong>if/else</strong>: 真正的“创建/销毁”。条件切换时会触发 DOM 树的移除和重建。适用于<strong>状态不常改变</strong>的大块 UI。</li><li><strong>visibility</strong>: 仅仅是“看不见”，组件还在树上，内存还在。适用于<strong>频繁切换</strong>（如闪烁光标、折叠面板）的场景。 <ul><li><code>Visibility.None</code>: 不占位，不绘制（类似 <code>display: none</code>）。</li><li><code>Visibility.Hidden</code>: 占位，不绘制（类似 <code>visibility: hidden</code>）。</li></ul></li></ul><h3 id="_3-3-图片加载优化" tabindex="-1">3.3 图片加载优化 <a class="header-anchor" href="#_3-3-图片加载优化" aria-label="Permalink to &quot;3.3 图片加载优化&quot;">​</a></h3><ul><li><strong>指定尺寸</strong>：尽量使用 <code>resize</code> 属性缩小解码尺寸，避免将 4K 图片原样加载到 小头像框中。</li><li><strong>同步 vs 异步</strong>：默认 Image 组件异步加载，不阻塞 UI。确保不要在主线程进行耗时的图片处理。</li></ul><hr><h2 id="四、状态管理优化" tabindex="-1">四、状态管理优化 <a class="header-anchor" href="#四、状态管理优化" aria-label="Permalink to &quot;四、状态管理优化&quot;">​</a></h2><h3 id="_4-1-状态更新的精确控制" tabindex="-1">4.1 状态更新的精确控制 <a class="header-anchor" href="#_4-1-状态更新的精确控制" aria-label="Permalink to &quot;4.1 状态更新的精确控制&quot;">​</a></h3><p>不要把整个大对象设为 <code>@State</code> 并传递给子组件。ArkUI 的状态观测是基于第一层属性的。</p><p><strong>❌ 性能差的做法</strong>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@State </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bigData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: BigObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传递整个对象，任何小属性变动可能导致不必要的深层检测</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ChildComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ data: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.bigData })</span></span></code></pre></div><p><strong>✅ 性能好的做法</strong>： 按需传递基本类型或使用 <code>@ObjectLink</code> 拆分粒度。</p><h3 id="_4-2-避免在-build-中做复杂计算" tabindex="-1">4.2 避免在 build() 中做复杂计算 <a class="header-anchor" href="#_4-2-避免在-build-中做复杂计算" aria-label="Permalink to &quot;4.2 避免在 build() 中做复杂计算&quot;">​</a></h3><p><code>build()</code> 函数会频繁执行。这是定义 UI 结构的场所，不是写业务逻辑的地方。</p><ul><li><strong>Bad</strong>: <code>Text(this.calculateComplexValue(this.count))</code></li><li><strong>Good</strong>: 在 <code>@Watch</code> 或事件回调中计算好，存入 <code>@State showValue</code>，<code>build</code> 中直接读取。</li></ul><hr><h2 id="五、线程模型与并发-concurrency" tabindex="-1">五、线程模型与并发 (Concurrency) <a class="header-anchor" href="#五、线程模型与并发-concurrency" aria-label="Permalink to &quot;五、线程模型与并发 (Concurrency)&quot;">​</a></h2><p>UI 线程（主线程）极其宝贵，任何超过 5ms 的逻辑都应该警惕。</p><h3 id="_5-1-taskpool-任务池" tabindex="-1">5.1 TaskPool (任务池) <a class="header-anchor" href="#_5-1-taskpool-任务池" aria-label="Permalink to &quot;5.1 TaskPool (任务池)&quot;">​</a></h3><p>对于复杂的计算（如大文件校验、图像滤镜、复杂数据排序），<strong>必须</strong>移出主线程。 HarmonyOS 推荐使用 <code>TaskPool</code>（比 Worker 更轻量易用）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { taskpool } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@kit.ArkTS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Concurrent</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computeHeavyTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 模拟耗时计算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 UI 线程调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> taskpool.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(computeHeavyTask, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="六、实战工具-deveco-profiler" tabindex="-1">六、实战工具：DevEco Profiler <a class="header-anchor" href="#六、实战工具-deveco-profiler" aria-label="Permalink to &quot;六、实战工具：DevEco Profiler&quot;">​</a></h2><p>没有数据支撑的优化不可靠。DevEco Studio 内置的 Profiler 是强大的诊断工具。</p><h3 id="_6-1-启动分析" tabindex="-1">6.1 启动分析 <a class="header-anchor" href="#_6-1-启动分析" aria-label="Permalink to &quot;6.1 启动分析&quot;">​</a></h3><p>点击底部的 <strong>Profiler</strong> 标签 -&gt; 选择设备和 App -&gt; 点击 <strong>Realtime Monitor</strong>。</p><h3 id="_6-2-关键指标解读" tabindex="-1">6.2 关键指标解读 <a class="header-anchor" href="#_6-2-关键指标解读" aria-label="Permalink to &quot;6.2 关键指标解读&quot;">​</a></h3><ol><li><p><strong>Frame (帧率分析)</strong></p><ul><li><strong>绿色帧</strong>：正常。</li><li><strong>红色帧</strong>：掉帧。</li><li><strong>操作</strong>：点击红色帧，下方会展开 Call Stack（调用栈）。</li><li><strong>分析</strong>：查看是否有 <code>GCRuntime</code>（垃圾回收）或 <code>Layout[n]</code>（过度布局）耗时过长。</li></ul></li><li><p><strong>ArkTS Memory (内存分析)</strong></p><ul><li>查看 Heap Dump（堆快照）。</li><li>如果发现某种对象（如 <code>EntryAbility</code> 或自定义组件）数量只增不减，说明存在<strong>内存泄漏</strong>。</li></ul></li></ol><h3 id="_6-3-smartperf-host-高级" tabindex="-1">6.3 SmartPerf Host (高级) <a class="header-anchor" href="#_6-3-smartperf-host-高级" aria-label="Permalink to &quot;6.3 SmartPerf Host (高级)&quot;">​</a></h3><p>对于系统级性能分析（如查看 RenderService、System 进程耗时），可以使用 SmartPerf 工具抓取 trace 文件分析。</p><hr><h2 id="七、总结-checklist" tabindex="-1">七、总结 Checklist <a class="header-anchor" href="#七、总结-checklist" aria-label="Permalink to &quot;七、总结 Checklist&quot;">​</a></h2><p>在发布 App 前，请对照以下清单自查：</p><ol><li>[ ] <strong>列表流畅度</strong>：是否使用了 <code>LazyForEach</code> + <code>@Reusable</code> + <code>cachedCount</code>？</li><li>[ ] <strong>布局层级</strong>：是否移除了无用的 Container？最大嵌套深度是否控制在 5-8 层以内？</li><li>[ ] <strong>图片内存</strong>：是否加载了过大的图片？是否及时释放了 PixelMap？</li><li>[ ] <strong>状态更新</strong>：日志里是否有 &quot;Component update&quot; 过于频繁？</li><li>[ ] <strong>GC 频率</strong>：是否在每一帧（如 <code>onScroll</code>）里创建了大量临时对象？</li></ol><hr><blockquote><p><strong>性能优化从未有终点</strong>。它需要在功能开发和体验之间寻找平衡点。合理运用上述技巧，将显著提升 HarmonyOS 应用的运行流畅度。</p></blockquote>`,68)])])}const c=i(l,[["render",e]]);export{E as __pageData,c as default};
