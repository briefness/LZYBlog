# 04. 厨房与餐桌：渲染与提交

一个常见的误解是：React 的“渲染 (Render)”就是“更新 DOM”。

事实上，这是两个完全独立的步骤。理解这一点，对于优化 React 性能至关重要。

## 心理模型：餐厅运作流程

想象在一家繁忙的餐厅。

*   **Trigger (触发)**：客人（User/Code）点单。
*   **Render (渲染)**：厨师（React）在厨房里根据订单准备菜品。注意，这时候菜还没端出去，厨师可能在尝试摆盘，或者把做错的菜倒掉重做。这是**内部过程**。
*   **Commit (提交)**：服务员把最终做好的菜端到客人的桌子上（DOM）。这是**外部展示**。

### 步骤 1: 触发渲染 (Triggering a Render)

只有两件事能让 React 的厨房开火：
1.  **组件初次挂载**（餐厅开业）。
2.  **State 发生变化**（不论是组件自己的 State，还是祖先组件传下来的）。

一旦触发，React 就会安排一次“渲染”。

### 步骤 2: 渲染阶段 (The Render Phase)

这是最容易被误解的一步。

**“渲染”在 React 中仅仅意味着：调用组件函数。**

React 会看着当前的 State，询问组件：“现在的界面**应该**长什么样？”
组件函数运行，返回一段 JSX（也就是一份虚拟的 DOM 蓝图）。

这就像厨师在脑海里或者案板上构思这道菜。在这个阶段，**屏幕上没有任何变化**（客人还没吃到菜）。

*   **Virtual DOM (虚拟 DOM)**：这可以想象成厨师的草稿纸。React 会对比“这次的草稿”和“上次的草稿”。
*   **Reconciliation (协调)**：如果厨师发现这次的订单和上次完全一样（Diffing 结果无差异），他就会说：“这道菜跟刚才那道一模一样，不用重新端了。”

如果组件函数运行了（渲染了），但返回的 JSX 没变，React 就不会去动真正的 DOM。这就是为什么“重新渲染”通常很便宜，而“DOM 更新”很昂贵。

### 步骤 3: 提交阶段 (The Commit Phase)

如果 React 发现草稿有变化（比如 `<h1>` 的字变了，或者 `<div>` 的颜色变了），它就会进入提交阶段。

这时候，React 会真正操作 DOM API（`appendChild`, `removeChild`, `setAttribute`），把变化应用到浏览器页面上。

这就像服务员终于把菜端上了桌。只有在这一步，用户才能看到界面的更新。

## 为什么 Key 很重要？

在渲染列表时，React 经常警告需要加 `key`。为什么？

回到餐厅模型。假设桌子上有三盘菜：[鱼香肉丝, 宫保鸡丁, 土豆丝]。
现在订单变了，要把“鱼香肉丝”删掉，变成：[宫保鸡丁, 土豆丝]。

如果没有 `key`（身份 ID）：
1.  React 看到位置 1 以前是鱼香肉丝，现在是宫保鸡丁。React 会想：“这盘菜变了！”于是它把鱼香肉丝倒掉，重新做一盘宫保鸡丁。
2.  React 看到位置 2 以前是宫保鸡丁，现在是土豆丝。React 会想：“这也变了！”于是它把宫保鸡丁倒掉，重新做一盘土豆丝。
3.  React 看到位置 3 没有了，于是把原来的土豆丝盘子撤走。

这也太浪费了！厨师明明只需要把第一盘撤走，后面两盘往前挪一下就行。

如果有 `key`：
React 知道每盘菜的身份证。
1.  它发现 ID 为“宫保鸡丁”的菜还在，只是位置变了。
2.  它发现 ID 为“土豆丝”的菜也在，只是位置变了。
3.  它发现 ID 为“鱼香肉丝”的菜没了。

于是 React 只需要做一个操作：**删除 DOM 中第一个节点**。后面两个节点都不用重新创建，直接复用。

## 总结

1.  **渲染 != 更新 DOM**。组件可能每秒渲染 100 次，但如果不产生视觉变化，React 就不会触碰 DOM。
2.  **三步走**：触发 (Trigger) -> 渲染 (Render / 纯计算) -> 提交 (Commit / 操作 DOM)。
3.  **Key 是身份证明**。它告诉 React 哪些组件只是换了位置，哪些是真正需要销毁或重建的。
