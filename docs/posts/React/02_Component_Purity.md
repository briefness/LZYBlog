# 02. 组件纯度与生命周期

在上一章中，建立了 React 的核心方程 `UI = f(state)`。要让这个方程稳定运行，函数 `f`（即组件）必须遵守一个严格的规则：**保持纯粹 (Purity)**。

本章将深入探讨什么是“纯组件”，以及如果不遵守这一规则时会发生什么奇怪的 Bug。

## 心理模型：自动售货机

想象一台老式的机械自动售货机。

*   **输入**：投入特定的硬币（Props），按下特定的按钮（State）。
*   **输出**：它掉出一瓶特定的饮料（UI）。

这就是一个**纯粹**的系统。如果重复投入相同的硬币并按下相同的按钮，它**永远**会掉出相同的饮料。它不会因为今天是星期二就掉咖啡，也不会因为上一位顾客买的是可乐就受影响。

如果这台售货机不仅是一台机器，还是一个复杂的 AI，它可能会偷偷记录用户的购买习惯（外部变量），或者因为心情不好（随机数）而不出货。这就**不纯**了。

React 的组件必须像那台机械售货机一样：**给定相同的输入，永远返回相同的 UI，并且不改变任何外部状态。**

## 什么是副作用 (Side Effects)？

在编程中，“副作用”是指函数在返回结果之外，还做了其他事情，比如：

1.  修改了函数外部的变量。
2.  修改了传入的参数对象。
3.  发起网络请求。
4.  直接操作 DOM（如 `document.title = ...`）。

### 危险的副作用示例

```javascript
let guestCount = 0;

function GuestList({ name }) {
  // ❌ 严重的副作用：修改外部变量
  guestCount = guestCount + 1;
  return <h2>{name} is guest #{guestCount}</h2>;
}
```

如果在页面上渲染这个 `GuestList` 三次，预期的结果可能是：
*   Jack is guest #1
*   Sally is guest #2
*   Mike is guest #3

但如果 React 因为某种原因（比如组件复用、严格模式双重检查）重新渲染了其中一个组件，`guestCount` 就会再次增加，原本是 #1 的 Jack 可能会突然变成 #4。UI 变得不可预测。

### 纯粹的版本

```javascript
function GuestList({ name, number }) {
  // ✅ 纯粹：只依赖 Props，不修改任何东西
  return <h2>{name} is guest #{number}</h2>;
}
```

在这里，`number` 是通过 Props 传入的。组件就像数学公式 `y = 2x` 一样，只要 x 确定，y 永远确定。

## 严格模式 (Strict Mode) 的双重检查

如果在开发模式下运行 React，可能会发现 console.log 会打印两次，或者组件看起来被执行了两次。

这是 React 故意为之的 **“双重渲染” (Double Invocation)** 机制。

想象一下，为了检查自动售货机是否纯粹，维修工采取了一个暴力测试法：**每当顾客买东西时，迅速让机器空转运行一次（不掉货），然后再正式运行一次（掉货）。**

如果机器是纯粹的（机械结构），两次运行的结果应该完全一致。
如果机器内部有奇怪的计数器（副作用），两次运行就会导致计数器加倍，暴露问题。

React 的 `<StrictMode>` 就是这个维修工。它在开发环境下会故意把组件函数调用两次。如果组件是不纯的（比如上面的 `GuestList` 修改了 `guestCount`），立刻就会看到的奇怪的数字（比如 2, 4, 6），从而意识到代码有问题。

> **注意**：这种双重调用仅在**开发模式**下发生，生产环境不会有性能损耗。

## 何时执行副作用？

可能会有疑问：“但这不合理啊！应用肯定需要网络请求、需要订阅事件、需要修改 DOM，这些不都是副作用吗？”

是的，应用当然需要副作用。但在 React 中，副作用不能发生在**渲染过程中 (Render Phase)**。

渲染过程是指 React 调用组件函数、计算 JSX 的那一瞬间。这一瞬间必须是纯粹的计算。

副作用应该发生在：
1.  **事件处理函数 (Event Handlers)**：当用户点击按钮时。
2.  **useEffect**：当组件渲染完成并“挂载”到屏幕后（下一章会详细讲）。

如果不在这两个地方，那一律属于“渲染过程”，必须保持纯净。

## 总结

1.  **纯组件**是 React 渲染逻辑的基石，不仅是为了哲学上的美感，更是为了并发渲染等高级特性不出错。
2.  **副作用**（修改外部状态、请求等）绝对不能在组件函数体内直接执行。
3.  **Strict Mode** 是开发者的好帮手，它通过双重调用帮助揪出隐蔽的纯度 BUG。
