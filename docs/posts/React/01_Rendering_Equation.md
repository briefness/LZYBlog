# 01. 渲染公式：UI = f(state)

React 的核心并非特定的语法（如 JSX）或特定的 API（如 Hooks），而是一个极其简洁的数学心智模型。理解这一模型是掌握 React 的关键，且能解释 90% 的“组件不更新”类问题。

## 核心方程

React 的本质可以被概括为以下公式：

```math
UI = f(state)
```

在这个公式中：
*   **UI**：用户在屏幕上看到的最终界面（DOM）。
*   **f**：组件函数（Function）。
*   **state**：当前应用的数据快照。

这明确了 React 的工作方式：**视图（UI）只是数据（State）在特定时刻的纯粹映射**。一旦数据发生变化，React 会再次运行函数 `f`，计算出新的 UI，并自动更新屏幕。

开发者不需要手动修改 DOM（即不需要手动把像素点画到屏幕上），只需要改变数据（State），UI 的更新是自动发生的副作用。

### 1. 声明式 vs 命令式

为了理解这个公式的威力，可以对比两种编程范式。

假设需要实现一个简单的场景：**当点击按钮时，将图标变成实心，并改变颜色。**

#### 命令式 (Imperative) - 类似于 jQuery 或 原生 JS
命令式编程关注的是“过程”。开发者像指挥官一样，一步步下达指令。

```mermaid
graph LR
    A[用户点击] --> B[找到图标元素]
    B --> C[移除 outline 类名]
    C --> D[添加 filled 类名]
    D --> E[修改 style.color 为红色]
```

这种代码不仅繁琐，而且脆弱。如果应用状态复杂（例如：同时有网络请求返回、用户输入、定时器触发），开发者必须手动管理每一个 DOM 变更的顺序和冲突，极易产生 Bug。

#### 声明式 (Declarative) - React 的方式
声明式编程关注的是“结果”。开发者只需要描述“可以在不同状态下显示的 UI 长什么样”。

```mermaid
graph LR
    A[用户点击] --> B[更新状态 isLiked = true]
    B --> C[React 重新运行组件]
    C --> D[组件根据 isLiked 返回对应的红色实心图标]
    D --> E[React 自动更新 DOM]
```

开发者只需要告知 React：“如果是点赞状态，就渲染一个红色的实心爱心；否则，渲染一个灰色的空心爱心。”至于如何从空心变实心，React 会自己处理。

### 2. 心智模型：画家与画布

可以将 React 的渲染过程想象成一位**快照摄影师**或**数字画家**。

*   **DOM (浏览器)** 是**画布**。
*   **React** 是**画家**。
*   **组件 (Component)** 是**拍摄指令**。
*   **State** 是**被拍摄的场景**。

当 State（场景）发生变化时，开发者并不直接去画布上涂改（直接操作 DOM）。相反，开发者告诉 React（画家）：“场景变了，请拍一张新照片。”

React 会查看新的场景，拍摄一张全新的“虚拟照片”（Virtual DOM），然后将其与上一张照片进行比对（Diffing）。它会精准地找出两张照片的不同之处（比如只是某人的手抬起来了），然后只在画布上修改那一部分像素（Patching Real DOM）。

这个过程保证了开发者永远不需要操心“如何高效更新 DOM”，而只需要专注于“当前场景应该长什么样”。

## 组件：纯粹的转换器

在 React 中，组件本质上就是 JavaScript 函数。但为了符合 `UI = f(state)` 的模型，组件必须保持**纯粹 (Purity)**。

什么是纯函数？

1.  **只负责计算**：给定相同的输入（Props），永远返回相同的输出（JSX）。
2.  **无副作用**：在计算过程中，不修改外部变量，不修改传入的参数，不在此处发起网络请求。

```javascript
// ✅ 纯组件：输入 width=100，永远输出 style 为 100 的 div
function Box({ width }) {
  return <div style={{ width }} />;
}

// ❌ 不纯组件：依赖外部变量，每次渲染结果可能不同，甚至修改外部变量
let count = 0;
function BadBox() {
  count = count + 1; // 副作用：修改了外部变量
  return <div>{count}</div>;
}
```

如果组件不纯，React 的渲染结果就会变得不可预测。想象一下，如果 `2 + 2` 有时等于 4，有时等于 5，数学公式就崩溃了。同样，如果组件不纯，`UI = f(state)` 这个公式也会失效，导致 UI 显示错误。

## 总结

1.  React 的核心是 **UI = f(state)**。
2.  开发者定义状态（State）和组件逻辑（f），React 负责将结果同步到屏幕（UI）。
3.  这是一种**声明式**的编程范式，关注“是什么（结果）”而非“怎么做（过程）”。
4.  组件应当是**纯函数**，保证输入与输出的确定性关系。
